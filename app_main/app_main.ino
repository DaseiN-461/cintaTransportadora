
#include "BluetoothSerial.h"
#include <ezButton.h>

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

#if !defined(CONFIG_BT_SPP_ENABLED)
#error Serial Bluetooth not available or not enabled. It is only available for the ESP32 chip.
#endif


int btn1 = 0;
int btn2 = 35;


int numberKeyPresses = 0;
int vel_step = 5;

int vel_VFD;
int vel_current;

int count_timeout = 0;
int timeout = 10;

////////////////////////////////////////////////Defines for DeepSleep//////////////////////////////////////////////

#define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex

RTC_DATA_ATTR int bootCount = 0;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BluetoothSerial SerialBT;

ezButton btnL(btn1);
ezButton btnR(btn2);


void btnConfig();
void btnHandler();
void print_wakeup_reason();
void isr_btn1();
void isr_btn2();


void setup() {
  
  btnConfig();
  
  Serial.begin(115200);
  SerialBT.begin("Cinta transportadora"); //Bluetooth device name
  delay(1000);

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////   Debugging                    /////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ++bootCount;
  Serial.println("Boot number: " + String(bootCount));

  //Print the wakeup reason for ESP32
  print_wakeup_reason();

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  SerialBT.println(SerialBT);
  Serial.println("The device started, now you can pair it with bluetooth!");

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////      Pair with BLE Server      /////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////     Read velocity from VFD     /////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////

  vel_current = vel_VFD;
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////


  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////     Loop, process and transmit vel     //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    

    
  unsigned long previousTime = millis();
  
  while(count_timeout < timeout){
    unsigned long currentTime = millis();

    btnHandler();
     
    if(currentTime - previousTime >= 1000){
      count_timeout++;
      Serial.printf("time out: [%d]\r\n", count_timeout);

      previousTime = currentTime;
    }
    
  }
                   ///////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////          if timeout            /////////////////////////////////////////
                   ///////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////     Send data to BLE Server
                   ///////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////        Go to Deep Sleep        /////////////////////////////////////////
                   ///////////////////////////////////////////////////////////////////////////////////////////

  esp_sleep_enable_ext0_wakeup(GPIO_NUM_33,1); //1 = High, 0 = Low

  esp_sleep_enable_ext0_wakeup(GPIO_NUM_0,0); //1 = High, 0 = Low
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_35,0); //1 = High, 0 = Low

  //If you were to use ext1, you would use it like
  //esp_sleep_enable_ext1_wakeup(BUTTON_PIN_BITMASK,ESP_EXT1_WAKEUP_ANY_HIGH);

  //Go to sleep now
  Serial.println("Going to sleep now");
  esp_deep_sleep_start();
  Serial.println("This will never be printed");
}




void loop() {
  
}



void btnConfig(){
  btnL.setDebounceTime(50);
  btnR.setDebounceTime(150);
  
  pinMode(btn1, INPUT_PULLUP);
  attachInterrupt(btn1, isr_btn1, FALLING);
  
  pinMode(btn2, INPUT_PULLUP);
  attachInterrupt(btn2, isr_btn2, FALLING);
}

void btnHandler(){
  
  
  btnL.loop();
  btnR.loop();
  

  if (btnL.isPressed()) {
    //numberKeyPresses--;
    vel_current -= vel_step;
    Serial.printf("velocity: [%d]\r\n",vel_current);
    //Serial.println(numberKeyPresses);
    
  }

  if (btnR.isPressed()) {
    //numberKeyPresses++;
    vel_current += vel_step;
    Serial.printf("velocity: [%d]\r\n",vel_current);
    //Serial.println(numberKeyPresses);
    
  }
}


void isr_btn1(){
  count_timeout = 0;
  //btnHandler();
  
  
}
void isr_btn2(){
  count_timeout = 0;
  //btnHandler();
  
  
}


void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}
